<!-- ---
sidebar_position: 5
--- -->

# Building and executing SQL queries

## Use case

SQL Chains and Agents can be used to **build and run** SQL queries based on natural language prompts. LangChain is compatible with any SQL dialect supported by **SQLAlchemy**, such as MS SQL, MySQL, MariaDB, PostgreSQL, Oracle SQL, Databricks, and SQLite.

Some use cases may be:

- Generating queries that will be run based on natural language questions
- Creating chatbots that can answer questions based on database data
- Building custom dashboards based on insights a user wants to analyze

## Overview

LangChain provides a set of tools for any user to interact with SQL Databases in many ways. We can:

1. `Build SQL queries` based on user questions
2. `Obtain insights from an SQL database` using the SQL Database Chain for handling both query creation and execution
3. `Interact with a complex SQL database in a robust way` using the SQL Agent which contains a set of tools which make it more robust and flexible when creating and running queries

## Quickstart

First, get required packages and set environment variables:

```
pip install openai
export OPENAI_API_KEY="..."
```

For this use case, we will use an **SQLite connection** with **Chinook database**. Follow [installation steps](https://database.guide/2-sample-databases-sqlite/) and place `Chinhook.db` file in a `notebooks` folder at the root of this repository. Then we can load the database:

```python
from langchain.utilities import SQLDatabase

db = SQLDatabase.from_uri("sqlite:///../../../../notebooks/Chinook.db")
```

## Case 1: Obtain an appropriate SQL query using natural language

```python
from langchain.chains import create_sql_query_chain
from langchain.chat_models import ChatOpenAI
```

Let's create the chain that will build the SQL Query:

```python
chain = create_sql_query_chain(ChatOpenAI(temperature=0), db)
```

And just try it out:

```python
response = chain.invoke({"question":"How many employees are there"})

print(response)
```

    SELECT COUNT(*) FROM Employee

After building the SQL query based on a user question, we can execute the query:

```python
db.run(response)
```

    '[(8,)]'

As we can see, the SQL Query Builder chain **only created** the query, and we handled the **query execution separately**.

### Go deeper

The query builder can be improved in several ways, such as (but not limited to):

- Customizing database description to your specific use case
- Hardcoding a few examples of questions and their corresponding SQL query in the prompt
- Using a vector database to include dynamic examples that are relevant to the specific user question

All these examples involve customizing the chain's prompt. For example, we can include a few examples in our prompt like so:

```python

TEMPLATE = """Given an input question, first create a syntactically correct {dialect} query to run, then look at the results of the query and return the answer.
Use the following format:

Question: "Question here"
SQLQuery: "SQL Query to run"
SQLResult: "Result of the SQLQuery"
Answer: "Final answer here"

Only use the following tables:

{table_info}.

Some examples of SQL queries that corrsespond to questions are:

{few_shot_examples}

Question: {input}"""

CUSTOM_PROMPT = PromptTemplate(
    input_variables=["input", "few_shot_examples", "table_info", "dialect"], template=TEMPLATE
)

```

## Case 2: Obtain insights from SQL database using natural language

We can use `SQLDatabaseChain` from `langchain_experimental` to handle the whole process of both creating
and running the SQL queries.

```python
from langchain.llms import OpenAI
from langchain_experimental.sql import SQLDatabaseChain

# Create the chain
llm = OpenAI(temperature=0, verbose=True)
db_chain = SQLDatabaseChain.from_llm(llm, db, verbose=True)
```

And we can run it:

```python
db_chain.run("How many employees are there?")
```

    > Entering new SQLDatabaseChain chain...
    How many employees are there?
    SQLQuery:

    SELECT COUNT(*) FROM "Employee";
    SQLResult: [(8,)]
    Answer:There are 8 employees.
    > Finished chain.


    'There are 8 employees.'

As we can see, we get the same result as the previous case,
but now the chain **also handles the query execution**, and provides a final
answer based on the user question and the query result.

**Be careful** while using this approach as it is susceptible to `SQL Injection`. The chain is
executing queries that are created by an LLM, and weren't validated. (_e.g. records may be created, modified or deleted unintentionally_).
This is why we see the `SQLDatabaseChain` is inside `langchain_experimental`.

### Go deeper

The performance of the `SQLDatabaseChain` can be enhanced in several ways:

- [Adding sample rows](#adding-sample-rows)
- [Specifying custom table information](#custom-table-information)
- [Using Query Checker](https://python.langchain.com/docs/modules/chains/popular/sqlite#use-query-checker), as sometimes the LLM generates invalid SQL with errors that can be self-corrected, using parameter `use_query_checker=True`
- [Customizing the LLM Prompt](https://python.langchain.com/docs/modules/chains/popular/sqlite#customize-prompt) to include specific instructions or relevant information, using parameter `prompt=CUSTOM_PROMPT`
- [Get intermediate steps](https://python.langchain.com/docs/modules/chains/popular/sqlite#return-intermediate-steps) in order to access the SQL statement as well as the final result, using parameter `return_intermediate_steps=True`
- [Limit the number of rows](https://python.langchain.com/docs/modules/chains/popular/sqlite#choosing-how-to-limit-the-number-of-rows-returned) a query will return, so as to avoid exceeding the prompt max length or consume tokens, using parameter `top_k=5`

You might find [SQLDatabaseSequentialChain](https://python.langchain.com/docs/use_cases/tabular/sqlite#sqldatabasesequentialchain)
useful for cases in which the number of tables in the database is large.
This `Sequential Chain` handles the process of:

1. Determining which tables to use based on the user question
2. Calling the normal SQL database chain using only relevant tables

#### Example: Adding Sample Rows

In some cases, providing sample data can help the LLM construct the correct queries for cases in which the data format is not obvious. For example, we can tell LLM that artists are saved with their full names by providing two rows from the Track table.

```python
db = SQLDatabase.from_uri(
    "sqlite:///../../../../notebooks/Chinook.db",
    include_tables=['Track'], # we include only one table to save tokens in the prompt :)
    sample_rows_in_table_info=2)
```

The sample rows are added to the prompt after each corresponding table's column information.
We can use `db.table_info` and check which sample rows are included:

```python
print(db.table_info)
```

        CREATE TABLE "Track" (
            "TrackId" INTEGER NOT NULL,
            "Name" NVARCHAR(200) NOT NULL,

            [....rest of `create table` statement]
        )

        /*
        2 rows from Track table:
        TrackId Name    AlbumId MediaTypeId GenreId Composer    Milliseconds    Bytes   UnitPrice
        1   For Those About To Rock (We Salute You) 1   1   1   Angus Young, Malcolm Young, Brian Johnson   343719  11170334    0.99
        2   Balls to the Wall   2   2   1   None    342562  5510424 0.99
        */

## Case 3: Recover from errors and answer questions about the schema

LangChain has an SQL Agent which provides a more flexible way of interacting with SQL Databases than the `SQLDatabaseChain`.

The main advantages of using the SQL Agent are:

- It can answer questions based on the databases' schema as well as on the databases' content (like describing a specific table)
- It can recover from errors by running a generated query, catching the traceback and regenerating it correctly

Here's how we can use the SQL agent in LangChain:

```python
from langchain.agents import create_sql_agent
from langchain.agents.agent_toolkits import SQLDatabaseToolkit
from langchain.agents import AgentExecutor
from langchain.agents.agent_types import AgentType
```

To initialize the agent, we use `create_sql_agent` function. This agent contains
the `SQLDatabaseToolkit` which contains tools to create and execute queries, check
query syntax, retrieve table descriptions, and more.

```python
agent_executor = create_sql_agent(
    llm=OpenAI(temperature=0),
    toolkit=SQLDatabaseToolkit(db=db, llm=OpenAI(temperature=0)),
    verbose=True,
    agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
)
```

### Agent task example #1 - Running queries

```python
agent_executor.run(
    "List the total sales per country. Which country's customers spent the most?"
)
```

    > Entering new AgentExecutor chain...
    Action: list_tables_sql_db
    Action Input: ""
    Observation: Invoice, MediaType, Artist, InvoiceLine, Genre, Playlist, Employee, Album, PlaylistTrack, Track, Customer
    Thought: I should look at the schema of the relevant tables to see what columns I can use.
    Action: schema_sql_db
    Action Input: "Invoice, Customer"
    Observation:
    CREATE TABLE "Customer" (
        "CustomerId" INTEGER NOT NULL,
        "FirstName" NVARCHAR(40) NOT NULL,
        "LastName" NVARCHAR(20) NOT NULL,
        "Company" NVARCHAR(80),
        "Address" NVARCHAR(70),
        "City" NVARCHAR(40),
        "State" NVARCHAR(40),
        "Country" NVARCHAR(40),
        "PostalCode" NVARCHAR(10),
        "Phone" NVARCHAR(24),
        "Fax" NVARCHAR(24),
        "Email" NVARCHAR(60) NOT NULL,
        "SupportRepId" INTEGER,
        PRIMARY KEY ("CustomerId"),
        FOREIGN KEY("SupportRepId") REFERENCES "Employee" ("EmployeeId")
    )

    SELECT * FROM 'Customer' LIMIT 3;
    CustomerId FirstName LastName Company Address City State Country PostalCode Phone Fax Email SupportRepId
    1 Luís Gonçalves Embraer - Empresa Brasileira de Aeronáutica S.A. Av. Brigadeiro Faria Lima, 2170 São José dos Campos SP Brazil 12227-000 +55 (12) 3923-5555 +55 (12) 3923-5566 luisg@embraer.com.br 3
    2 Leonie Köhler None Theodor-Heuss-Straße 34 Stuttgart None Germany 70174 +49 0711 2842222 None leonekohler@surfeu.de 5
    3 François Tremblay None 1498 rue Bélanger Montréal QC Canada H2G 1A7 +1 (514) 721-4711 None ftremblay@gmail.com 3


    CREATE TABLE "Invoice" (
        "InvoiceId" INTEGER NOT NULL,
        "CustomerId" INTEGER NOT NULL,
        "InvoiceDate" DATETIME NOT NULL,
        "BillingAddress" NVARCHAR(70),
        "BillingCity" NVARCHAR(40),
        "BillingState" NVARCHAR(40),
        "BillingCountry" NVARCHAR(40),
        "BillingPostalCode" NVARCHAR(10),
        "Total" NUMERIC(10, 2) NOT NULL,
        PRIMARY KEY ("InvoiceId"),
        FOREIGN KEY("CustomerId") REFERENCES "Customer" ("CustomerId")
    )

    SELECT * FROM 'Invoice' LIMIT 3;
    InvoiceId CustomerId InvoiceDate BillingAddress BillingCity BillingState BillingCountry BillingPostalCode Total
    1 2 2009-01-01 00:00:00 Theodor-Heuss-Straße 34 Stuttgart None Germany 70174 1.98
    2 4 2009-01-02 00:00:00 Ullevålsveien 14 Oslo None Norway 0171 3.96
    3 8 2009-01-03 00:00:00 Grétrystraat 63 Brussels None Belgium 1000 5.94
    Thought: I should query the Invoice and Customer tables to get the total sales per country.
    Action: query_sql_db
    Action Input: SELECT c.Country, SUM(i.Total) AS TotalSales FROM Invoice i INNER JOIN Customer c ON i.CustomerId = c.CustomerId GROUP BY c.Country ORDER BY TotalSales DESC LIMIT 10
    Observation: [('USA', 523.0600000000003), ('Canada', 303.9599999999999), ('France', 195.09999999999994), ('Brazil', 190.09999999999997), ('Germany', 156.48), ('United Kingdom', 112.85999999999999), ('Czech Republic', 90.24000000000001), ('Portugal', 77.23999999999998), ('India', 75.25999999999999), ('Chile', 46.62)]
    Thought: I now know the final answer
    Final Answer: The customers from the USA spent the most, with a total of $523.06.

    > Finished chain.





    'The customers from the USA spent the most, with a total of $523.06.'

### Agent task example #2 - Describing a Table

```python
agent_executor.run("Describe the playlisttrack table")
```

    > Entering new  chain...

    Invoking: `list_tables_sql_db` with `{}`


    Album, Artist, Track, PlaylistTrack, InvoiceLine, sales_table, Playlist, Genre, Employee, Customer, Invoice, MediaType
    Invoking: `schema_sql_db` with `PlaylistTrack`



    CREATE TABLE "PlaylistTrack" (
        "PlaylistId" INTEGER NOT NULL,
        "TrackId" INTEGER NOT NULL,
        PRIMARY KEY ("PlaylistId", "TrackId"),
        FOREIGN KEY("TrackId") REFERENCES "Track" ("TrackId"),
        FOREIGN KEY("PlaylistId") REFERENCES "Playlist" ("PlaylistId")
    )

    /*
    3 rows from PlaylistTrack table:
    PlaylistId  TrackId
    1   3402
    1   3389
    1   3390
    */The `PlaylistTrack` table has two columns: `PlaylistId` and `TrackId`. It is a junction table that represents the relationship between playlists and tracks.

    Here is the schema of the `PlaylistTrack` table:

    ```
    CREATE TABLE "PlaylistTrack" (
        "PlaylistId" INTEGER NOT NULL,
        "TrackId" INTEGER NOT NULL,
        PRIMARY KEY ("PlaylistId", "TrackId"),
        FOREIGN KEY("TrackId") REFERENCES "Track" ("TrackId"),
        FOREIGN KEY("PlaylistId") REFERENCES "Playlist" ("PlaylistId")
    )
    ```

    Here are three sample rows from the `PlaylistTrack` table:

    ```
    PlaylistId   TrackId
    1            3402
    1            3389
    1            3390
    ```

    Please let me know if there is anything else I can help you with.

    > Finished chain.





    'The `PlaylistTrack` table has two columns: `PlaylistId` and `TrackId`. It is a junction table that represents the relationship between playlists and tracks. \n\nHere is the schema of the `PlaylistTrack` table:\n\n```\nCREATE TABLE "PlaylistTrack" (\n\t"PlaylistId" INTEGER NOT NULL, \n\t"TrackId" INTEGER NOT NULL, \n\tPRIMARY KEY ("PlaylistId", "TrackId"), \n\tFOREIGN KEY("TrackId") REFERENCES "Track" ("TrackId"), \n\tFOREIGN KEY("PlaylistId") REFERENCES "Playlist" ("PlaylistId")\n)\n```\n\nHere are three sample rows from the `PlaylistTrack` table:\n\n```\nPlaylistId   TrackId\n1            3402\n1            3389\n1            3390\n```\n\nPlease let me know if there is anything else I can help you with.'

### Go deeper

To learn more about the SQL Agent and how it works we refer to the [SQL Agent Toolkit](https://python.langchain.com/docs/integrations/toolkits/sql_database) documentation.
