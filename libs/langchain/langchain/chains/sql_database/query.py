from typing import List, Optional, TypedDict, Union,Dict

from langchain.chains.sql_database.prompt import PROMPT, SQL_PROMPTS,DECIDER_PROMPT_WITH_QUESTION
from langchain.tools.sql_database.prompt import QUERY_CHECKER_PROMPT
from langchain.schema.language_model import BaseLanguageModel
from langchain.schema.runnable import RunnableLambda
from langchain.schema.output_parser import NoOpOutputParser
from langchain.schema.messages import AIMessage
from langchain.schema.prompt_template import BasePromptTemplate
from langchain.schema.runnable import Runnable, RunnableParallel
from langchain.utilities.sql_database import SQLDatabase

def _strip(text: str) -> str:
    return text.strip()


class SQLInput(TypedDict):
    """Input for a SQL Chain."""

    question: str


class SQLInputWithTables(TypedDict):
    """Input for a SQL Chain."""

    question: str
    table_names_to_use: List[str]


def create_sql_query_chain(
    llm: BaseLanguageModel,
    db: SQLDatabase,
    prompt: Optional[BasePromptTemplate] = None,
    k: int = 5,
    decider_chain: bool = False
) -> Runnable[Union[SQLInput, SQLInputWithTables], str]:
    """Create a chain that generates SQL queries.

    *Security Note*: This chain generates SQL queries for the given database.

        The SQLDatabase class provides a get_table_info method that can be used
        to get column information as well as sample data from the table.

        To mitigate risk of leaking sensitive data, limit permissions
        to read and scope to the tables that are needed.

        Optionally, use the SQLInputWithTables input type to specify which tables
        are allowed to be accessed.

        Control access to who can submit requests to this chain.

        See https://python.langchain.com/docs/security for more information.

    Args:
        llm: The language model to use
        db: The SQLDatabase to generate the query for
        prompt: The prompt to use. If none is provided, will choose one
            based on dialect. Defaults to None.
        k: The number of results per select statement to return. Defaults to 5.

    Returns:
        A chain that takes in a question and generates a SQL query that answers
        that question.
    """
    inputs = {
        "input": lambda x: x["question"] + "\nSQLQuery: ",
        "top_k": lambda _: k,
        "table_info": lambda x: db.get_table_info(
            table_names=x.get("table_names_to_use")
        ),
    }
    def _get_table_info_query_chain(table_names: AIMessage) -> Dict[str, str]:
        """
        Constructs input for the SQL query chain based on the output of the decider chain.

        This Runnable Lambda function processes the output of the decider chain, which
        includes the selected question and relevant table names. It then creates the
        input dictionary required for the SQL query chain, which includes the SQL query
        question, the desired top_k value, and table information retrieved from the
        database for the selected tables.

        Args:
            table_names (AIMessage): The message containing the selected question and
            relevant table names from the decider chain.

        Returns:
            Dict[str, str]: A dictionary containing the input data for the SQL query chain.
        """

        question = table_names.content.split('\n')[0].replace("Question:","").strip()
        table_names_list = list(map(lambda x:x.strip(),
                                    table_names.content.split('\n')[1].replace("Answer:","").strip().split(',')))
        final_input_dict = {}
        final_input_dict["input"] = question + "\nSQLQuery: "
        final_input_dict["top_k"] = k
        final_input_dict["table_info"] = db.get_table_info(
                table_names=table_names_list
            )
        return final_input_dict
    
    def _get_query_output(sql_query: AIMessage) -> Dict[str, str]:
        """
        Constructs input for the query checker chain based on the output of the SQL query chain.

        This Runnable Lambda function processes the SQL query generated by the SQL query chain
        and constructs the input dictionary required for the query checker chain. The input
        includes the SQL query itself and the dialect of the database being queried.

        Args:
            sql_query (AIMessage): The message containing the generated SQL query from the SQL
            query chain.

        Returns:
            Dict[str, str]: A dictionary containing the input data for the query checker chain.
        """
        return {'query':sql_query.content,'dialect':db.dialect}        

    if prompt is not None:
        prompt_to_use = prompt
    elif db.dialect in SQL_PROMPTS:
        prompt_to_use = SQL_PROMPTS[db.dialect]
    else:
        prompt_to_use = PROMPT

    if "dialect" in prompt_to_use.input_variables:
        inputs["dialect"] = lambda _: (db.dialect, prompt_to_use)
    
    if not decider_chain:
        return (
            RunnableParallel(inputs)
            | prompt_to_use
            | llm.bind(stop=["\nSQLResult:"])
            | RunnableLambda(_get_query_output)
            | QUERY_CHECKER_PROMPT
            | llm.bind(stop=["\nSQL Query: "])
            | NoOpOutputParser()
            | _strip
        )
    else:
        decider_chain_inputs = {
        "query": lambda x: x["question"],
        "table_names": lambda _: db.get_usable_table_names()}
        return (RunnableParallel(decider_chain_inputs)
        | DECIDER_PROMPT_WITH_QUESTION
        | llm.bind(stop=["\nQuestion: "])
        | RunnableLambda(_get_table_info_query_chain)
        | prompt_to_use
        | llm.bind(stop=["\nSQLResult:"])
        | RunnableLambda(_get_query_output)
        | QUERY_CHECKER_PROMPT
        | llm.bind(stop=["\nSQL Query: "])
        | NoOpOutputParser()
        | _strip
        )