import logging
from typing import (
    Any,
    AsyncIterator,
    Dict,
    Iterator,
    List,
    Optional,
)

from langchain.callbacks.manager import (
    AsyncCallbackManagerForLLMRun,
    CallbackManagerForLLMRun,
)
from langchain.llms.base import LLM
from langchain.pydantic_v1 import Field, root_validator
from langchain.schema.output import GenerationChunk
from langchain.utils import get_from_dict_or_env

logger = logging.getLogger(__name__)


class ErnieBot(LLM):
    """Baidu `ERNIE-Bot` large language model.

    This LLM is the implement only about Baidu ERNIE ErnieBot.
    Use Baidu `langchain.llms.QianfanLLMEndpoint` for more
    LLMs.

    ERNIE-Bot is a large language model developed by Baidu,
    covering a huge amount of Chinese data.

    To use, you should have the `erniebot_ak` and `erniebot_sk` set,
    or set the environment variable `ERNIEBOT_AK` and `ERNIEBOT_SK`.

    Note:
    access_token will be automatically generated based on client_id and client_secret,
    and will be regenerated after expiration (30 days).

    Default model is `ERNIE-Bot-turbo`,
    currently supported models are `ernie-bot-3.5`, `ernie-bot-turbo`

    Example:
        .. code-block:: python

            from langchain.llms import ErnieBot
            llm = ErnieBot(model_name='ernie-bot-turbo')
    """

    model_kwargs: Dict[str, Any] = Field(default_factory=dict)

    client: Any

    erniebot_ak: Optional[str] = None
    erniebot_sk: Optional[str] = None

    streaming: Optional[bool] = False
    """Whether to stream the results or not."""

    model_name: str = "ernie-bot-turbo"
    """Model name. 
    
    supported models:
    - ERNIE-Bot-turbo
    - ERNIE-Bot
    """

    request_timeout: Optional[int] = 60
    """request timeout for chat http requests"""

    top_p: Optional[float] = 0.8
    temperature: Optional[float] = 0.95
    penalty_score: Optional[float] = 1
    """Model params, only supported in ERNIE-Bot and ERNIE-Bot-turbo.
    In the case of other model, passing these params will not affect the result.
    """

    @root_validator()
    def validate_enviroment(cls, values: Dict) -> Dict:
        values["erniebot_ak"] = get_from_dict_or_env(
            values,
            "erniebot_ak",
            "ERNIEBOT_AK",
        )
        values["erniebot_sk"] = get_from_dict_or_env(
            values,
            "erniebot_sk",
            "ERNIEBOT_SK",
        )
        try:
            import erniebot

            erniebot.ak = values["erniebot_ak"]
            erniebot.sk = values["erniebot_sk"]

            values["client"] = erniebot.ChatCompletion
        except ImportError:
            raise ValueError(
                "erniebot package not found, please install it with "
                "`pip install erniebot`"
            )
        return values

    @property
    def _identifying_params(self) -> Dict[str, Any]:
        return {
            **{"model": self.model_name},
            **super()._identifying_params,
        }

    @property
    def _llm_type(self) -> str:
        """Return type of llm."""
        return "ernie-bot"

    @property
    def _default_params(self) -> Dict[str, Any]:
        """Get the default parameters for calling OpenAI API."""
        normal_params = {
            "model": self.model_name,
            "stream": self.streaming,
            "request_timeout": self.request_timeout,
            "top_p": self.top_p,
            "temperature": self.temperature,
            "penalty_score": self.penalty_score,
        }

        return {**normal_params, **self.model_kwargs}

    def _convert_prompt_msg_params(
        self,
        prompt: str,
        **kwargs: Any,
    ) -> dict:
        if "streaming" in kwargs:
            kwargs["stream"] = kwargs.pop("streaming")
        return {
            **{
                "messages": [{"role": "user", "content": prompt}],
            },
            **self._default_params,
            **kwargs,
        }

    def _call(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> str:
        """Implement of Erniebot call()
        Args:
            prompt: The prompt to pass into the model.
        Returns:
            The string generated by the model.

        Example:
            .. code-block:: python
                llm = ErniBot()
                response = llm("Tell me a joke.")
        """
        if self.streaming:
            completion = ""
            for chunk in self._stream(prompt, stop, run_manager, **kwargs):
                completion += chunk.text
            return completion
        params = self._convert_prompt_msg_params(prompt, **kwargs)
        response_payload = self.client.create(**params)

        return response_payload["result"]

    async def _acall(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[AsyncCallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> str:
        if self.streaming:
            completion = ""
            async for chunk in self._astream(prompt, stop, run_manager, **kwargs):
                completion += chunk.text
            return completion

        params = self._convert_prompt_msg_params(prompt, **kwargs)
        response_payload = await self.client.acreate(**params)

        return response_payload["result"]

    def _stream(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[CallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> Iterator[GenerationChunk]:
        params = self._convert_prompt_msg_params(prompt, **{**kwargs, "stream": True})
        for res in self.client.create(**params):
            if res:
                chunk = GenerationChunk(text=res["result"])
                yield chunk
                if run_manager:
                    run_manager.on_llm_new_token(chunk.text)

    async def _astream(
        self,
        prompt: str,
        stop: Optional[List[str]] = None,
        run_manager: Optional[AsyncCallbackManagerForLLMRun] = None,
        **kwargs: Any,
    ) -> AsyncIterator[GenerationChunk]:
        params = self._convert_prompt_msg_params(prompt, **{**kwargs, "stream": True})
        async for res in await self.client.acreate(**params):
            if res:
                chunk = GenerationChunk(text=res["result"])

                yield chunk
                if run_manager:
                    await run_manager.on_llm_new_token(chunk.text)
